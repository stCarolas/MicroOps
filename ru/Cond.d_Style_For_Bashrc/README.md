### Проблематика

Любой линуксоид со временем начинает кастомизировать свой шел, 
будь то bash, zsh или fish. 
Как минимум, 
всегда есть подобранные под себя алиасы и функции-шорткаты.
Как правило, 
все желаемые настройки прописываются в одном файле -
к примеру ~/.bashrc, если говорить про bash. 
В итоге получается громадный файл,
в особых случаях достигающий сотен строк, 
разграниченный в лучшем случае комментариями на секции.
В общем-то, 
ни к чему плохому это не приводит, 
и обычно даже не мешает пользователю. 
Вполне себе способ управлять своими настройками.

Проблемы возникают,
если эти же настройки требуется внести на другой системе. 
Допустим, 
у вас есть ноутбук и стационарный компьютер,
на которых вы работаете,
выбирая инструмент в зависимости от задачи.
Вполне логично,
что большинство настроек
( те же самые алиасы )
вы хотите видеть одинаковыми,
чтобы использовать одни алиасы и на стаце, и на ноуте.
Большинство статей и рекомендаций на эту тему в интернете посоветуют git для синхронизации настроек. 
Казалось бы, 
вполне хорошее решение проблемы.
Но есть одно но -
не учитывается уникальность хостов.
Что это значит?

Предположим, 
у вас кроме ноута и стаца есть еще рабочий комп, 
стац в офисе работодателя.
Предположим, 
интернет в офисе раздается только через прокси сервер 
( с фильтрацией трафика и прочими мерами безопасности ).
В таком случае на рабочем компе вы настраиваете системную переменную  all_proxy, на которую будут смотреть приложения,
и настраиваете, естественно, в .bashrc.
Если вы пытаетесь синхронизировать этот bashrc через гит,
то вы или теряете эту настройку,
или добавляете ее на все остальные свои машины,
теряя возможность зайти в интернет, 
так как указанная в all_proxy прокся не доступна.

Таких примеров можно привести много, и не только с системными переменными.
И если вдруг у вас есть несколько систем, на которых вы регулярно работаете, то вполне возможно, вы испытываете те же проблемы. 

### Как быть

Если мы говорим о синхронизации настроек в общем случае, 
то конечно надо менять подход к решению задачи - 
не использовать гит для синхронизации настроек, 
использовать другие, 
более заточенные под описанную проблему инструменты.
Но об этом - 
в отдельной статье.

В нашем случае, 
с bashrc, 
достаточно применить так называемый conf.d style -
распространненый в линуксе способ задания конфигураций.
Примеров такого стиля достаточно много на любой linux системе
( xorg, NetworkManager dispatcher scripts, и так далее ), 
но неискушенному пользователю,
как правило,
они не знакомы, - 
практически все такие конфигурации лежат глубоко в системных настройках
и скрыты от пользователя за красивым ui. 

Итак, выглядит этот стиль примерно так ( в случае моего bashrc )
```
~/.config/bash
├── config.bash
├── common.d
│   ├── debug.bash
│   └── path.bash
└── interactive.d
    ├── alacritty.bash
    ├── ansible.bash
    ├── docker.bash
    ├── fzf.bash
    ├── git.bash
    ├── gunstock.bash
    ├── lf.bash
    ├── ps1.bash
    ├── tmux.bash
    ├── vim.bash
    └── work.bash

2 directories, 19 files
```

Суть, 
как читатель может видеть, 
состоит в делении всех настроек на отдельные файлы, 
содержащих связный набор настроек - 
т.е. все алиасы и прочие настройки для гита вынесены в git.bash,  
все настройки для tmux - в tmux.bash. 
Это позволяет гораздо легче обновлять специфические настройки - 
если не хотите трогать остальные конфиги, 
хотите только добавить алиас для tmux - 
обновляете файл tmux.bash, 
оставляя все остальные без имзенений, 
что позволяет избегать опасности перезатереть не синхронизированные настройки. 
Естественно, 
если вы все храните в одном большом bashrc, 
то предстоит мерж при синхронизации в описанном случае - 
когда из гита вы хотите забрать новую настройку, 
но при этом еще не заливали туда свои изменения.
Если вы все еще синхронизируете настройки через гит, 
и если воспользуетесь conf.d стилем конфигурации, 
то достаточно легко разрешить вышеописанную ситуацию с all_proxy - 
выносите в отдельный файл, 
все кроме него добавляется и синхронизируется через гит, 
а конфиг с all_proxy остается достоянием рабочего стаца. 

Все эти файлы с настройками кладутся в определенные директории,
по общепринятому соглашению заканчивающихся на .d, 
что указывает на назначение папки - 
хранить настройки. 
Обычно программа, 
для которой эти настройки предназначаются, 
и которая поддерживает такой стиль конфигурации,
сама зачитывает все конфиги из этой директории,
что позволяет динамически добавлять/удалять файлы с нужными настройками,
не заботять о прописывании названия или пути конфига - 
просто закинь конфиг и все. Но это не наш случай - bash из коробки так не делает.
