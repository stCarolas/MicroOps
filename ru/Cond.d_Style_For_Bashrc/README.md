### Проблематика

Любой линуксоид со временем начинает кастомизировать свой шел, 
будь то bash, zsh или fish. 
Как минимум, 
всегда есть подобранные под себя алиасы и функции-шорткаты.
Как правило, 
все желаемые настройки прописываются в одном файле -
к примеру ~/.bashrc, если говорить про bash. 
В итоге получается громадный файл,
в особых случаях достигающий сотен строк, 
разграниченный в лучшем случае комментариями на секции.
В общем-то, 
ни к чему плохому это не приводит, 
и обычно даже не мешает пользователю. 
Вполне себе способ управлять своими настройками.

Проблемы возникают,
если эти же настройки требуется внести на другой системе. 
Допустим, 
у вас есть ноутбук и стационарный компьютер,
на которых вы работаете,
выбирая инструмент в зависимости от задачи.
Вполне логично,
что большинство настроек
( те же самые алиасы )
вы хотите видеть одинаковыми,
чтобы использовать одни алиасы и на стаце, и на ноуте.
Большинство статей и рекомендаций на эту тему в интернете посоветуют git для синхронизации настроек. 
Казалось бы, 
вполне хорошее решение проблемы.
Но есть одно но -
не учитывается уникальность хостов.
Что это значит?

Предположим, 
у вас кроме ноута и стаца есть еще рабочий комп, 
стац в офисе работодателя.
Предположим, 
интернет в офисе раздается только через прокси сервер 
( с фильтрацией трафика и прочими мерами безопасности ).
В таком случае на рабочем компе вы настраиваете системную переменную  all_proxy, на которую будут смотреть приложения,
и настраиваете, естественно, в .bashrc.
Если вы пытаетесь синхронизировать этот bashrc через гит,
то вы или теряете эту настройку,
или добавляете ее на все остальные свои машины,
теряя возможность зайти в интернет, 
так как указанная в all_proxy прокся не доступна.

Таких примеров можно привести много, и не только с системными переменными.
И если вдруг у вас есть несколько систем, на которых вы регулярно работаете, то вполне возможно, вы испытываете те же проблемы. 

### Как быть

Если мы говорим о синхронизации настроек в общем случае, 
то конечно надо менять подход к решению задачи - 
не использовать гит для синхронизации настроек, 
использовать другие, 
более заточенные под описанную проблему инструменты.
Об этом - 
чуть позже.

В нашем случае, 
с bashrc, 
достаточно применить так называемый conf.d style -
распространенный в линуксе способ задания конфигураций.
Примеров такого стиля достаточно много на любой linux системе
( xorg, NetworkManager dispatcher scripts, и так далее ), 
но неискушенному пользователю,
как правило,
они не знакомы, - 
практически все такие конфигурации лежат глубоко в системных настройках
и скрыты от пользователя за красивым ui. 

Итак, выглядит этот стиль примерно так ( в случае моего bashrc )
```
~/.config/bash
├── config.bash
├── common.d
│   ├── debug.bash
│   └── path.bash
└── interactive.d
    ├── alacritty.bash
    ├── ansible.bash
    ├── docker.bash
    ├── fzf.bash
    ├── git.bash
    ├── gunstock.bash
    ├── lf.bash
    ├── ps1.bash
    ├── tmux.bash
    ├── vim.bash
    └── work.bash

2 directories, 19 files
```

Суть, 
как читатель может видеть, 
состоит в делении всех настроек на отдельные файлы, 
содержащих связный набор настроек - 
т.е. все алиасы и прочие настройки для гита вынесены в git.bash,  
все настройки для tmux - в tmux.bash. 
Какие плюсы мы от этого получили?
Ну, примерно следующие:

- Если вы все еще синхронизируете настройки через гит, 
то достаточно легко разрешить вышеописанную ситуацию с all_proxy:  
выносите в отдельный файл, 
все кроме него добавляется и синхронизируется через гит, 
а конфиг с all_proxy остается достоянием рабочего стаца. 

- Навигация/отображение структуры по папкам и файлам внутри папок лучше поддерживается текстовыми редакторами, 
нежели навигация по комментам внутри файлика

- Это позволяет гораздо легче обновлять специфические настройки - 
поскольку файлы меньше по размеру, разрешать мерж конфликты в них проще, чем мержить один большой файл.

- Если вы используете  несколько шелов одновременно ( достаточно популярна комбинация из двух шелов - bash для скриптинга и zsh для терминала )

Все эти файлы с настройками кладутся в определенные директории,
по общепринятому соглашению заканчивающихся на .d, 
что указывает на назначение папки - 
хранить настройки. 
Обычно программа, 
для которой эти настройки предназначаются, 
и которая поддерживает такой стиль конфигурации,
сама зачитывает все конфиги из этой директории,
что позволяет динамически добавлять/удалять файлы с нужными настройками,
не заботять о прописывании названия или пути конфига - 
просто закинь конфиг и все. Но это не наш случай - bash из коробки так не делает.
Для баша пишем примерно такой трюк:
```
for f in ~/.config/bash/common.d/*; 
    do source $f; 
done

case $- in
  *i*) 
      debug "INTERACTIVE"

      for f in ~/.config/bash/interactive.d/*; 
        do source $f; 
      done
  *) 
      debug "NON_INTERACTIVE"
      ;;
esac
```
Тут вроде бы все понятно - всегда грузим скрипты из common.d, если сессия интерактивная - то грузим и все скрипты из interactive.d .
